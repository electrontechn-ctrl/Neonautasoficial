<!doctype html>
<html lang="es">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Captura con fondo (local, estable)</title>

<style>
  body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    margin: 0; min-height: 100vh; display: grid; place-items: center;
    background: #0c0c0c; color: #fff;
  }
  .wrap { display: grid; gap: 12px; place-items: center; }

  /* Área que vamos a capturar */
  #design {
    position: relative;
    width: 360px;           /* tamaño final */
    height: 560px;
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0 12px 30px rgba(0,0,0,.35);
    isolation: isolate;     /* asegura el stacking */
  }

  /* >>> Capa de FONDO REAL (NO pseudo-elemento) <<< */
  #bg {
    position: absolute; inset: 0; z-index: 0;
    background: #222 center / cover no-repeat; /* cambia a 'contain' si no quieres recorte */
  }

  .overlay {
    position: absolute; inset: 0; z-index: 1;
    background: linear-gradient(to bottom, rgba(0,0,0,.25), rgba(0,0,0,.45));
    pointer-events: none;
  }

  .content {
    position: relative; z-index: 2;
    padding: 24px; text-align: center; display: grid; gap: 8px;
  }

  button, label[for="bgfile"] {
    padding: 10px 14px; border-radius: 10px; border: 1px solid #444;
    background: #1c1c1c; color: #fff; cursor: pointer;
  }
  #preview { max-width: 360px; display: none; border-radius: 12px; }
  small { color: #b7b7b7; }
  input[type="file"] { display: none; }
</style>

<div class="wrap">
  <div id="design">
    <div id="bg"></div>           <!-- FONDO real -->
    <div class="overlay"></div>
    <div class="content">
      <h1>Mi diseño</h1>
      <p>Texto, logos, etc.</p>
    </div>
  </div>

  <div style="display:flex; gap:8px; flex-wrap:wrap; justify-content:center;">
    <label for="bgfile">Elegir imagen de fondo…</label>
    <button id="btn-png">Guardar como PNG</button>
    <button id="btn-jpg">Guardar como JPG</button>
  </div>

  <small>Todo se guarda <b>localmente</b>. Nada se sube.</small>
  <img id="preview" alt="Previsualización" />
</div>

<!-- Input de archivo (el label de arriba lo dispara) -->
<input id="bgfile" type="file" accept="image/*">

<!-- Librería DOM → imagen -->
<script src="https://unpkg.com/html-to-image@1.11.11/dist/html-to-image.js"></script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  const $ = (s) => document.querySelector(s);
  const bg = $('#bg');
  const design = $('#design');
  const preview = $('#preview');

  // 1) Si existe ./fondofiesta.jpg en la misma carpeta, la cargo y la convierto a dataURL
  (async () => {
    try {
      const head = await fetch('../sources/img/fondofiesta.jpg', { method: 'HEAD' });
      if (head.ok) {
        const res = await fetch('../sources/img/fondofiesta.jpg');
        const blob = await res.blob();
        const reader = new FileReader();
        reader.onload = () => { bg.style.backgroundImage = `url('${reader.result}')`; };
        reader.readAsDataURL(blob); // dataURL evita CORS/tainted canvas
      }
    } catch (_) { /* si no existe, se queda el color #222 */ }
  })();

  // 2) Permitir elegir un fondo local (se convierte a dataURL)
  $('#bgfile').addEventListener('change', (e) => {
    const f = e.target.files?.[0]; if (!f) return;
    const reader = new FileReader();
    reader.onload = () => { bg.style.backgroundImage = `url('${reader.result}')`; };
    reader.readAsDataURL(f);
  });

  // Utilidades
  const pad = n => String(n).padStart(2,'0');
  const ts = () => { const d = new Date();
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}_${pad(d.getHours())}-${pad(d.getMinutes())}-${pad(d.getSeconds())}`;
  };

  async function captureToDataUrl(type = 'png', quality = 0.92) {
    try { if (document.fonts?.ready) await document.fonts.ready; } catch(e) {}
    const pixelRatio = Math.max(2, window.devicePixelRatio || 1);
    const opts = { pixelRatio, cacheBust: true, useCors: true, backgroundColor: null };
    return (type === 'jpeg' || type === 'jpg')
      ? await htmlToImage.toJpeg(design, { ...opts, quality })
      : await htmlToImage.toPng(design, opts);
  }

  async function dataUrlToBlob(dataUrl) {
    const res = await fetch(dataUrl); return await res.blob();
  }

  function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = Object.assign(document.createElement('a'), { href: url, download: filename });
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  async function captureAndSave(ext) {
    const isJpg = ext === 'jpg' || ext === 'jpeg';
    try {
      const dataUrl = await captureToDataUrl(isJpg ? 'jpeg' : 'png', 0.92);
      const blob = await dataUrlToBlob(dataUrl);
      preview.src = dataUrl; preview.style.display = 'block';
      downloadBlob(blob, `diseno-${ts()}.${isJpg ? 'jpg' : 'png'}`);
    } catch (e) {
      console.error('Error al capturar/guardar:', e);
      alert('No se pudo capturar o guardar. Revisa la consola.');
    }
  }

  $('#btn-png').addEventListener('click', () => captureAndSave('png'));
  $('#btn-jpg').addEventListener('click', () => captureAndSave('jpg'));
});
</script>
</html>
